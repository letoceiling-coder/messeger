# ЛОГИКА РАБОТЫ WEBSOCKET ЧАТА

## ОБЩАЯ СХЕМА

```
Клиент A                    Backend                    Клиент B
   │                           │                           │
   │─── Подключение (JWT) ────>│                           │
   │<─── Подтверждение ─────────│                           │
   │                           │                           │
   │─── Присоединение к комнатам чатов                     │
   │                           │                           │
   │─── message:send ─────────>│                           │
   │   {chatId, content}       │                           │
   │                           │─── Сохранение в БД ──────│
   │                           │─── Создание deliveries ──│
   │                           │                           │
   │<─── message:received ─────│                           │
   │   {message}                │                           │
   │                           │─── message:received ─────>│
   │                           │   {message}                │
   │                           │<─── delivered ─────────────│
   │                           │                           │
```

---

## 1. ПОДКЛЮЧЕНИЕ ПОЛЬЗОВАТЕЛЯ

### Шаг 1: Handshake с аутентификацией
```
Клиент подключается: ws://localhost:3000?token=JWT_TOKEN
```

**Логика:**
1. Клиент передает JWT токен в query параметре или заголовке
2. Сервер проверяет токен в `handleConnection()`
3. Если токен валиден - извлекается userId
4. Если токен невалиден - соединение отклоняется

### Шаг 2: Присоединение к комнатам
```
После успешного подключения:
1. Найти все чаты пользователя (где он участник)
2. Для каждого чата: socket.join(`chat:${chatId}`)
3. Обновить статус пользователя: isOnline = true
```

**Комнаты (Rooms):**
- Каждый чат = отдельная комната
- Формат: `chat:${chatId}`
- Пользователь автоматически присоединяется ко всем своим чатам

### Шаг 3: Уведомление о подключении
```
Сервер отправляет событие: user:online {userId}
Всем участникам чатов этого пользователя
```

---

## 2. ОТПРАВКА СООБЩЕНИЯ

### Событие: `message:send`

**Клиент → Сервер:**
```json
{
  "chatId": "uuid",
  "content": "Текст сообщения"
}
```

**Логика обработки:**

1. **Валидация:**
   - Проверка, что пользователь является участником чата
   - Проверка, что content не пустой
   - Проверка прав доступа

2. **Сохранение в БД:**
   ```sql
   INSERT INTO messages (chat_id, user_id, content, created_at)
   VALUES (chatId, userId, content, NOW())
   ```

3. **Создание записей доставки:**
   ```sql
   -- Для каждого участника чата (кроме отправителя)
   INSERT INTO message_deliveries (message_id, user_id, status)
   VALUES (messageId, recipientId, 'sent')
   ```

4. **Обновление чата:**
   ```sql
   UPDATE chats 
   SET updated_at = NOW(), last_message_at = NOW()
   WHERE id = chatId
   ```

5. **Отправка получателям:**
   - Найти всех участников чата (кроме отправителя)
   - Отправить событие `message:received` в комнату `chat:${chatId}`
   - Отправить подтверждение отправителю

---

## 3. ПОЛУЧЕНИЕ СООБЩЕНИЯ

### Событие: `message:received`

**Сервер → Клиент:**
```json
{
  "id": "message-uuid",
  "chatId": "chat-uuid",
  "userId": "sender-uuid",
  "content": "Текст сообщения",
  "createdAt": "2024-01-15T10:35:00Z"
}
```

**Логика:**
1. Сервер отправляет событие в комнату чата
2. Все участники комнаты получают событие (включая отправителя для подтверждения)
3. Клиент получает сообщение и обновляет UI

---

## 4. СТАТУС ДОСТАВКИ (delivered)

### Шаг 1: Создание записей при отправке
```
При создании сообщения:
- Для каждого участника чата (кроме отправителя)
- Создается запись в message_deliveries со статусом 'sent'
```

### Шаг 2: Обновление статуса при получении
```
Когда клиент получает message:received:
1. Клиент отправляет событие: message:delivered {messageId}
2. Сервер обновляет статус: 'sent' → 'delivered'
3. Обновляет delivered_at = NOW()
```

### Событие: `message:delivered`

**Клиент → Сервер:**
```json
{
  "messageId": "message-uuid"
}
```

**Логика:**
```sql
UPDATE message_deliveries
SET status = 'delivered', delivered_at = NOW()
WHERE message_id = messageId AND user_id = currentUserId
```

### Уведомление отправителя
```
Сервер отправляет событие: message:delivery_status
Отправителю сообщения:
{
  "messageId": "uuid",
  "userId": "recipient-uuid",
  "status": "delivered"
}
```

---

## 5. ОТКЛЮЧЕНИЕ ПОЛЬЗОВАТЕЛЯ

### Событие: `disconnect`

**Логика:**
1. Обновить статус: `isOnline = false`
2. Обновить `lastSeenAt = NOW()`
3. Отправить событие `user:offline {userId}` всем участникам чатов

---

## СТРУКТУРА СОБЫТИЙ

### Клиент → Сервер

| Событие | Данные | Описание |
|---------|--------|----------|
| `message:send` | `{chatId, content}` | Отправка сообщения |
| `message:delivered` | `{messageId}` | Подтверждение получения |
| `user:typing` | `{chatId, isTyping}` | Индикатор печати (опционально) |

### Сервер → Клиент

| Событие | Данные | Описание |
|---------|--------|----------|
| `message:received` | `{id, chatId, userId, content, createdAt}` | Новое сообщение |
| `message:delivery_status` | `{messageId, userId, status}` | Статус доставки |
| `user:online` | `{userId}` | Пользователь онлайн |
| `user:offline` | `{userId}` | Пользователь оффлайн |
| `user:typing` | `{userId, chatId, isTyping}` | Индикатор печати |

---

## БЕЗОПАСНОСТЬ

### 1. Аутентификация
- JWT токен проверяется при подключении
- Неавторизованные соединения отклоняются

### 2. Авторизация
- Проверка участия в чате перед отправкой сообщения
- Пользователь может отправлять только в свои чаты

### 3. Валидация
- Проверка формата данных
- Проверка длины сообщения
- Защита от SQL injection (Prisma)

### 4. Rate Limiting (рекомендуется для production)
- Ограничение количества сообщений в секунду
- Защита от спама

---

## ПОТОК ДАННЫХ (ПОЛНЫЙ ЦИКЛ)

```
1. Клиент A подключается
   → Сервер: проверка JWT, присоединение к комнатам
   
2. Клиент A отправляет сообщение
   → Сервер: message:send {chatId, content}
   → Сервер: сохранение в БД
   → Сервер: создание deliveries (status: 'sent')
   → Сервер: broadcast message:received в комнату чата
   
3. Клиент B получает сообщение
   → Клиент B: message:received {message}
   → Клиент B: отправка message:delivered {messageId}
   → Сервер: обновление статуса → 'delivered'
   → Сервер: отправка message:delivery_status отправителю
   
4. Клиент A видит статус доставки
   → Клиент A: message:delivery_status {messageId, userId, status: 'delivered'}
```

---

## ОБРАБОТКА ОШИБОК

### Типы ошибок:

1. **Невалидный токен:**
   - Соединение отклоняется
   - Событие: `error: {message: 'Unauthorized'}`

2. **Пользователь не участник чата:**
   - Событие: `error: {message: 'Access denied'}`

3. **Пустое сообщение:**
   - Событие: `error: {message: 'Message cannot be empty'}`

4. **Чат не найден:**
   - Событие: `error: {message: 'Chat not found'}`

---

## ОПТИМИЗАЦИЯ

### 1. Комнаты (Rooms)
- Использование Socket.io rooms для групповой рассылки
- Автоматическое управление подписками

### 2. Батчинг
- Группировка обновлений статуса доставки
- Batch обновления в БД

### 3. Кэширование
- Кэширование списка участников чата
- Кэширование информации о пользователях

---

## ИТОГОВАЯ ЛОГИКА

1. **Подключение:** JWT → Валидация → Присоединение к комнатам → user:online
2. **Отправка:** message:send → Валидация → Сохранение в БД → deliveries → broadcast
3. **Получение:** message:received → UI обновление → message:delivered → статус 'delivered'
4. **Отключение:** disconnect → isOnline = false → user:offline

Все операции атомарны и безопасны.
