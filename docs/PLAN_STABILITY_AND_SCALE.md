# План улучшений: стабильность связи, звонки, масштабирование и мобильные приложения

Документ объединяет рекомендации под текущий стек (NestJS, Socket.IO, WebRTC, nginx) и учитывает будущие приложения Android/iOS.

---

## 1. WebSocket

### 1.1 Текущее состояние

- **Клиент (frontend-web):** Socket.IO, автопереподключение с экспоненциальной задержкой (до 15 с), статусы `connected` / `disconnected` / `reconnecting`, баннер при потере связи.
- **Сервер:** NestJS + Socket.IO, нет явного heartbeat (Socket.IO имеет встроенный ping/pong, но таймауты можно уточнить).
- **Nginx:** для `/socket.io` уже заданы `Upgrade`, `Connection "upgrade"`, `proxy_read_timeout 86400`, `proxy_send_timeout 86400`.

### 1.2 Улучшения

| Задача | Описание | Приоритет | Где менять |
|--------|----------|-----------|------------|
| **Heartbeat (ping/pong) на сервере** | Явно настроить интервал ping и таймаут pong в Socket.IO сервере, чтобы быстрее отсекать «мёртвые» соединения (NAT, спящий режим). | Высокий | Backend: при создании IoAdapter или в `main.ts` задать `pingInterval`, `pingTimeout` (например, 25000 ms / 20000 ms). |
| **Очередь сообщений при отключении** | Пока `connectionStatus === 'disconnected'`, не отправлять сообщение в сокет, а класть в локальную очередь; после `connected` — отправить очередь по одному, показать пользователю «Сообщение будет отправлено после восстановления связи». | Высокий | Frontend: `websocket.service.ts` — буфер сообщений, флаг «офлайн»; при `connect` — drain очереди. UI: индикатор «N сообщений в очереди». |
| **Таймауты и Upgrade в nginx** | Проверить, что для HTTPS-блока тоже заданы те же таймауты и заголовки для `/socket.io`, что и для HTTP (сейчас в конфиге уже есть). При необходимости добавить `proxy_connect_timeout`, `proxy_read_timeout`, `proxy_send_timeout` в оба блока. | Средний | `nginx/messager-vps.conf`: сравнить оба `location /socket.io` (HTTP по IP и HTTPS по домену). |

**Рекомендуемые значения Socket.IO (сервер):**

```ts
// main.ts или при регистрации gateway
const io = app.get(IoAdapter).getIo();
io.engine.opts.pingInterval = 25000;  // 25 с
io.engine.opts.pingTimeout = 20000;   // 20 с — нет pong → disconnect
```

В NestJS это обычно задаётся через `IoAdapter` при создании адаптера с опциями.

---

## 2. Звонки (WebRTC)

### 2.1 Текущее состояние

- **STUN:** 5 серверов Google в `webrtc.service.ts`.
- **TURN:** закомментирован — при строгом NAT/файрволах звонки могут не устанавливаться.
- **Таймаут «соединение»:** на исходящем звонке ~28 с, затем «Не удалось подключиться»; на входящем — окно «Принять/Отклонить» не исчезает само по себе.
- **Нет таймаута «собеседник не ответил»:** инициатор может бесконечно ждать, если абонент не нажал «Принять»/«Отклонить».

### 2.2 Улучшения

| Задача | Описание | Приоритет | Где менять |
|--------|----------|-----------|------------|
| **TURN-сервер** | Добавить TURN в `ICE_SERVERS` в `webrtc.service.ts` (и в мобильных клиентах). Варианты: coturn на своём VPS, Xirsys/Twilio. Без TURN за строгим NAT звонки часто не проходят. | Высокий | Frontend: `webrtc.service.ts` — раскомментировать/добавить объект TURN в массив `ICE_SERVERS`. Backend: не обязателен для TURN (TURN — между клиентами и TURN-сервером). |
| **Таймаут «собеседник не ответил»** | После отправки `call:offer` запустить таймер (например, 45–60 с). Если за это время не пришёл `call:answer` и не пришёл `call:reject` — считать «нет ответа»: отправить инициатору событие (например, `call:no-answer` или повторно `call:end`), убрать звонок из `activeCalls`, на клиенте показать диалог «Собеседник не ответил» и закрыть экран звонка. | Высокий | Backend: `websocket.gateway.ts` — после `emit('call:offer', ...)` запланировать `setTimeout`. При приходе `call:answer` или `call:reject` — отменить таймер. По таймауту — emit инициатору, `activeCalls.delete(chatId)`. Frontend: подписаться на `call:no-answer` (или обрабатывать `call:end` с причиной) и показывать диалог. |
| **Проверка медиа до звонка** | Перед `initiateCall` вызывать `getUserMedia`; при отказе/ошибке показывать понятный диалог (нет микрофона/камеры, доступ запрещён). | Средний | Frontend: `VideoCall.tsx` / `webrtc.service.ts` — вызов до создания offer. |

**Пример TURN в webrtc.service.ts (заполнить своими данными):**

```ts
const TURN_SERVER = process.env.VITE_TURN_URL && process.env.VITE_TURN_USER && process.env.VITE_TURN_CREDENTIAL
  ? {
      urls: process.env.VITE_TURN_URL,
      username: process.env.VITE_TURN_USER,
      credential: process.env.VITE_TURN_CREDENTIAL,
    }
  : null;

const ICE_SERVERS: RTCIceServer[] = [
  { urls: 'stun:stun.l.google.com:19302' },
  // ... остальные STUN
  ...(TURN_SERVER ? [TURN_SERVER] : []),
];
```

Для мобильных приложений те же `ICE_SERVERS` (включая TURN) нужно использовать в нативном WebRTC (Android/iOS).

---

## 3. Масштабирование backend

| Задача | Описание | Приоритет | Где менять |
|--------|----------|-----------|------------|
| **Redis adapter для Socket.IO** | При нескольких инстансах NestJS (несколько процессов/хостов) один инстанс не знает сокеты других. Redis adapter синхронизирует события (join, emit) между инстансами, чтобы `to('chat:xxx')` доходило до клиентов на любом инстансе. | Средний (при 2+ инстансах) | Backend: установить `@socket.io/redis-adapter`, подключить Redis, в `main.ts` (или при создании IoAdapter) заменить стандартный адаптер на RedisAdapter. Тот же Redis можно использовать для сессий/кеша. |

**Когда не делать:** один инстанс backend — Redis adapter не нужен.

---

## 4. Nginx (краткая проверка)

Текущий конфиг уже содержит для WebSocket:

- `proxy_http_version 1.1`
- `proxy_set_header Upgrade $http_upgrade`
- `proxy_set_header Connection "upgrade"`
- `proxy_read_timeout 86400`; `proxy_send_timeout 86400`

**Рекомендация:** убедиться, что блок HTTPS (домен neekloai.ru) содержит те же параметры для `location /socket.io`, что и блок по IP. При необходимости добавить явно `proxy_connect_timeout 60s;` для единообразия.

---

## 5. Учёт мобильных приложений (Android / iOS)

Один и тот же backend и WebSocket API будут использоваться веб-клиентом и нативными приложениями. Важно заложить совместимость и типовое поведение.

| Аспект | Рекомендация |
|--------|--------------|
| **API и WebSocket** | Один и тот же REST API и Socket.IO (те же события: `message:send`, `message:received`, `call:offer`, `call:answer`, `call:end`, `call:reject`, `message:deleted` и т.д.). Мобильные клиенты подключаются к тому же URL (wss при HTTPS). |
| **WebRTC на мобильных** | Использовать те же ICE_SERVERS (STUN + TURN). На Android — WebRTC API или библиотеки (например, libwebrtc); на iOS — WebRTC framework. TURN особенно важен для мобильных сетей (переключение Wi‑Fi/4G, строгий NAT операторов). |
| **HTTPS** | Уже используется — микрофон/камера и WebRTC в браузере и в нативных обёртках работают по HTTPS/wss. |
| **Фон и разрывы связи** | На мобильных приложение уходит в фон, ОС может закрывать сокеты. Нужны: устойчивое переподключение (как сейчас на вебе), очередь сообщений при отключении, опционально — push-уведомления (FCM/APNs) для входящих сообщений и звонков, когда приложение в фоне. |
| **Права** | Запрос разрешений на микрофон/камеру при первом звонке; при отказе — понятное сообщение (аналогично вебу). |
| **Единый конфиг** | TURN/STUN и, при необходимости, таймауты звонков лучше хранить в одном месте (конфиг backend или общий конфиг приложений), чтобы веб и мобильные клиенты использовали одни и те же значения. |

Отдельный большой пласт — push-уведомления (FCM, APNs) и, при желании, звонки через VoIP push. Их можно вынести в следующий этап после стабилизации WebSocket и звонков.

---

## 6. Порядок внедрения (рекомендуемый)

1. **WebSocket**
   - Настроить heartbeat (ping/pong) на сервере Socket.IO.
   - Реализовать очередь сообщений при отключении на клиенте (веб).
   - Проверить nginx (таймауты и upgrade для обоих блоков).

2. **Звонки**
   - Добавить TURN в `webrtc.service.ts` (и позже в мобильных клиентах).
   - Реализовать таймаут «собеседник не ответил» на backend + диалог на клиенте.
   - Опционально: проверка медиа до инициации звонка.

3. **Масштабирование**
   - Вводить Redis adapter только при переходе на несколько инстансов backend.

4. **Мобильные приложения**
   - Использовать тот же API и Socket.IO; при разработке сразу закладывать TURN и переподключение; push и VoIP — отдельным этапом.

---

## 7. Ссылки

- Текущие детали и примеры по WebSocket и звонкам: `docs/WEBSOCKET_AND_CALLS.md`.
- Конфиг nginx: `nginx/messager-vps.conf`.
- Клиент WebSocket: `frontend-web/src/services/websocket.service.ts`.
- WebRTC: `frontend-web/src/services/webrtc.service.ts`.
- Логика звонков на сервере: `backend/src/websocket/websocket.gateway.ts` (call:initiate, call:answer, call:reject, call:end).

После реализации этих шагов связь (сообщения и звонки) станет стабильнее, а архитектура будет готова к масштабированию и к подключению приложений Android и iOS.
