# Предложение: API-Driven архитектура (всё из API, без локальных данных)

## Идея

- **Фронтенд** (Web, Android, iOS) — только рендерит данные, не хранит и не определяет содержимое
- **Все данные** — через API (чаты, сообщения, настройки, конфигурация, фичи)
- **Админ-панель** — управление статикой, настройками, вкл/выкл функционала
- **Мобильные приложения** — шаблоны, работают так же: только отображение данных из API

---

## 1. База данных: одна или две?

### Рекомендация: **одна БД с расширением**

**Почему не отдельная БД под новый дизайн:**
- Дублирование User, Chat, Message — сложная синхронизация
- Транзакции между БД (например, чат + пост) сложнее
- Два источника правды для одних и тех же сущностей

**План: расширить текущую Prisma-схему**

| Текущее | Новые сущности (из chat-hub) | Миграция |
|--------|------------------------------|----------|
| User ✓ | +phone, +dateOfBirth, +profileVideoUrl, +bio | Добавить поля |
| Chat ✓ | +isBot, +isChannel, +subscribersCount, +avatar | Добавить поля |
| Message ✓ | +waveform, +buttons(JSON), +views, расширить messageType | Добавить поля |
| — | Contact (связь User↔User) | Новая таблица |
| — | Call (история звонков) | Новая таблица |
| — | StickerPack, Sticker | Новые таблицы |
| — | FeedPost, FeedComment, FeedStory, FeedNotification | Новые таблицы |
| — | AppConfig, FeatureFlag, UserSettings | Новые таблицы |

**Оптимизация:** добавить индексы под частые запросы (чат по userId, сообщения по chatId+createdAt, посты по authorId и т.д.). Отдельная БД под новый дизайн не нужна.

---

## 2. Варианты реализации «всё из API»

### Вариант A: Единый endpoint конфигурации (app/bootstrap)

**Идея:** при старте приложение делает один запрос `GET /api/app/bootstrap`, получает всё нужное для «холодного» старта.

**Ответ API:**
```json
{
  "config": {
    "theme": "system",
    "appName": "Messenger",
    "version": "1.0"
  },
  "features": {
    "chats": true,
    "calls": true,
    "feed": true,
    "stickers": true,
    "channels": true
  },
  "ui": {
    "bottomNav": ["chats", "contacts", "calls", "feed"],
    "settingsSections": ["account", "privacy", "notifications", "theme"],
    "chatInputActions": ["attach", "voice", "sticker", "emoji"]
  },
  "defaults": {
    "messagesPageSize": 50,
    "theme": "system"
  }
}
```

**Плюсы:** один запрос при старте, быстрый рендер.  
**Минусы:** большой ответ, сложнее кешировать частично.

---

### Вариант B: Раздельные endpoints конфигурации

**Endpoints:**
- `GET /api/app/config` — глобальная конфигурация (тема, имя приложения, версия)
- `GET /api/app/features` — feature flags (chats, calls, feed, stickers, channels)
- `GET /api/app/ui-schema` — схема UI (навигация, секции настроек, кнопки ввода)
- `GET /api/app/defaults` — дефолты (messagesPageSize, theme и т.п.)

**Плюсы:** можно кешировать отдельно, точечное обновление.  
**Минусы:** больше запросов при старте.

---

### Вариант C: Конфигурация + Feature Flags (рекомендуемый)

**1. Единый bootstrap (лёгкий):**
```
GET /api/app/bootstrap
→ { config, features, uiSchema, defaults }
```

**2. Конфигурация управляется админкой:**
- Таблица `app_config` (key-value или JSON)
- Таблица `feature_flags` (name, enabled, env?)
- Таблица `ui_schema` (section, key, value JSON)

**3. Кеш на клиенте:**
- Сохранять bootstrap в localStorage/sessionStorage с TTL (например 5–15 мин)
- При старте: если кеш свежий — использовать, иначе запрос к API

---

## 3. Схема «статичных» и «динамичных» данных

| Тип данных | Источник | Частота обновления |
|------------|----------|--------------------|
| Конфиг приложения | API `/app/bootstrap` | Редко (кеш 15 мин) |
| Feature flags | API | Редко (кеш 5–15 мин) |
| UI-схема (навигация, секции) | API | Редко |
| Настройки пользователя | API `/users/me/settings` | При изменении |
| Чаты, сообщения, контакты | API + WebSocket | В реальном времени |
| Стикер-паки | API `/stickers/packs` | Редко (кеш 1 ч) |

Фронтенд **никогда** не хранит «истину» — только кеш для офлайн/производительности. Источник правды — бэкенд.

---

## 4. Админ-панель

**Назначение:** управление конфигурацией и статическими данными.

**Функции:**
- **Feature flags** — вкл/выкл: чаты, звонки, лента, стикеры, каналы
- **UI-схема** — порядок пунктов в нижней навигации, видимость секций настроек
- **Дефолтные значения** — messagesPageSize, theme по умолчанию
- **Стикер-паки** — добавление, редактирование, отключение
- **Тексты** (опционально) — приветствия, подсказки, названия кнопок

**Технологии:**
- Отдельный фронтенд (React/Next) с роутом `/admin`
- Роли: `admin` в JWT
- API: `GET/PATCH /api/admin/config`, `/api/admin/features`, `/api/admin/stickers` и т.д.

---

## 5. Мобильные приложения (Android / iOS) как шаблоны

**Идея:** WebView или нативный код — только рендер данных из API.

### Подход 1: React Native / Expo (как сейчас)

- Общий код с Web: API-клиент, типы, логика отображения
- Экран = `(data) => UI` — данные всегда из `useEffect`/хуков, которые вызывают API
- Никаких захардкоженных списков чатов, настроек и т.д.

### Подход 2: Нативные шаблоны (Kotlin/Swift)

- UI описан в коде, но **содержимое** приходит по API
- Пример: BottomNav — массив пунктов из `GET /api/app/ui-schema` → рендерим только то, что пришло
- Список чатов: `GET /api/chats` → RecyclerView/List

### Подход 3: WebView + PWA (самый «шаблонный»)

- Приложение = WebView, загружающая тот же SPA, что и веб
- Полностью одинаковое поведение и данные
- Минус: меньше нативной интеграции (камера, пуш, фон)

**Рекомендация:** оставаться на React Native/Expo, но:
- Вынести всю бизнес-логику в API-хуки
- Компоненты получают только `data` и `onAction` — без локальных констант

---

## 6. План внедрения (по этапам)

### Этап 1: Бэкенд — расширение схемы и API

1. Миграции Prisma: Contact, Call, StickerPack, Sticker, FeedPost, FeedComment, FeedStory, AppConfig, FeatureFlag
2. Добавить поля в User, Chat, Message
3. Endpoints: `/api/app/bootstrap`, `/api/users/me/settings`, CRUD для новых сущностей

### Этап 2: Bootstrap API

1. `GET /api/app/bootstrap` — config + features + uiSchema + defaults
2. Таблицы в БД для хранения этих данных
3. Админка (базовая) для редактирования

### Этап 3: Фронтенд — удаление моков

1. Заменить mockData, stickerPacks, defaultSettings на вызовы API
2. При старте: запрос bootstrap → сохранение в контекст/state
3. Рендер навигации, настроек, фич только по данным из API

### Этап 4: Админ-панель

1. UI для feature flags, ui-schema, стикеров
2. Роль admin, защита роутов

### Этап 5: Мобильные приложения

1. Унифицировать API-клиент (общий пакет или копия)
2. Убрать локальные данные, использовать те же endpoints
3. Bootstrap при старте приложения

---

## 7. Сводная таблица решений

| Вопрос | Рекомендация |
|--------|--------------|
| БД под новый дизайн | Одна БД, расширить текущую схему |
| Оптимизация БД | Добавить индексы, без отдельной БД |
| Источник данных для фронта | Только API (с кешем для производительности) |
| Статика и настройки | API + админка |
| Feature flags | Таблица в БД, endpoint в bootstrap |
| Android/iOS | Шаблоны на React Native, данные из API |
| Bootstrap | `GET /api/app/bootstrap` при старте |

---

## 8. Пример потока данных

```
[Старт приложения]
     ↓
GET /api/app/bootstrap (или из кеша)
     ↓
{ config, features, uiSchema, defaults }
     ↓
Рендер: нижняя навигация только по uiSchema.bottomNav
        экраны только если features.chats / features.feed и т.д.
     ↓
[Пользователь авторизован]
     ↓
GET /api/users/me + GET /api/users/me/settings
     ↓
Чаты: GET /api/chats + WebSocket
Сообщения: GET /api/chats/:id/messages + WebSocket
...
```

Фронтенд не решает, что показывать — он только отображает то, что вернул API.
