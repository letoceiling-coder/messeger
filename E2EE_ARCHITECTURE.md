# АРХИТЕКТУРА E2EE (END-TO-END ENCRYPTION)

## ОБЩАЯ СХЕМА

```
Клиент A                    Сервер                    Клиент B
   │                           │                           │
   │─── Обмен публичными ключами ─────────────────────────>│
   │<──────────────────────────────────────────────────────│
   │                           │                           │
   │─── Шифрование сообщения (публичный ключ B)           │
   │─── Отправка зашифрованного сообщения ───────────────>│
   │                           │─── Сохранение в БД ──────│
   │                           │─── Передача клиенту B ──>│
   │                           │                           │─── Дешифрование (приватный ключ B)
```

---

## ВЫБОР АЛГОРИТМА ШИФРОВАНИЯ

### Гибридный подход (рекомендуется)

**Для обмена ключами:** RSA (асимметричное)
- Каждый пользователь генерирует пару ключей (публичный/приватный)
- Публичный ключ хранится на сервере
- Приватный ключ хранится только на клиенте

**Для шифрования сообщений:** AES-256-GCM (симметричное)
- Для каждого чата генерируется общий ключ (shared secret)
- Ключ шифруется публичным ключом получателя и отправляется
- Сообщения шифруются AES ключом

**Преимущества:**
- Быстрое шифрование/дешифрование (AES)
- Безопасный обмен ключами (RSA)
- Меньший размер зашифрованных данных

---

## СТРУКТУРА ДАННЫХ

### Публичный ключ пользователя
```typescript
{
  userId: string;
  publicKey: string; // RSA публичный ключ (PEM формат)
  createdAt: Date;
}
```

### Зашифрованное сообщение
```typescript
{
  id: string;
  chatId: string;
  userId: string;
  encryptedContent: string; // Зашифрованный контент (Base64)
  encryptedKey: string; // Зашифрованный AES ключ (Base64)
  iv: string; // Initialization Vector (Base64)
  messageType: 'text' | 'voice';
  createdAt: Date;
}
```

---

## ПОТОК РАБОТЫ

### 1. Регистрация / Первый вход
```
1. Клиент генерирует пару ключей RSA (2048 бит)
2. Публичный ключ отправляется на сервер: POST /users/keys
3. Приватный ключ сохраняется локально (localStorage/AsyncStorage)
```

### 2. Создание чата
```
1. Клиент A запрашивает публичный ключ клиента B: GET /users/{userId}/public-key
2. Клиент A генерирует AES ключ для чата
3. AES ключ шифруется публичным ключом B
4. Зашифрованный ключ отправляется клиенту B через WebSocket
5. Клиент B дешифрует AES ключ своим приватным ключом
6. Оба клиента сохраняют AES ключ локально для этого чата
```

### 3. Отправка сообщения
```
1. Клиент A шифрует сообщение AES ключом чата
2. Отправляет зашифрованное сообщение через WebSocket
3. Сервер сохраняет зашифрованное сообщение в БД
4. Сервер отправляет зашифрованное сообщение клиенту B
5. Клиент B дешифрует сообщение AES ключом чата
```

---

## БЕЗОПАСНОСТЬ

### Хранение ключей
- **Публичные ключи:** На сервере (БД)
- **Приватные ключи:** Только на клиенте (localStorage/AsyncStorage)
- **AES ключи чатов:** Только на клиенте (localStorage/AsyncStorage)

### Защита приватных ключей
- Приватные ключи можно дополнительно защитить паролем пользователя (PBKDF2)
- Ключи хранятся в зашифрованном виде на клиенте

### Валидация
- Проверка подписи сообщений (HMAC)
- Проверка целостности данных

---

## ОБНОВЛЕНИЕ БАЗЫ ДАННЫХ

### Новая таблица: user_keys
```sql
CREATE TABLE user_keys (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  public_key TEXT NOT NULL,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

### Обновление таблицы messages
```sql
ALTER TABLE messages ADD COLUMN encrypted_content TEXT;
ALTER TABLE messages ADD COLUMN encrypted_key TEXT;
ALTER TABLE messages ADD COLUMN iv TEXT;
ALTER TABLE messages ADD COLUMN is_encrypted BOOLEAN DEFAULT false;
```

---

## БИБЛИОТЕКИ

### Backend (Node.js)
- `crypto` (встроенный модуль Node.js) - для RSA и AES
- `node-forge` или `crypto-js` (опционально, для дополнительных функций)

### Frontend Web
- `crypto-js` - для AES шифрования
- `node-forge` (через browserify) или Web Crypto API - для RSA

### Mobile (React Native)
- `react-native-crypto` или `expo-crypto` - для шифрования
- `react-native-rsa-native` - для RSA операций

---

## ОГРАНИЧЕНИЯ

1. **Голосовые сообщения:**
   - Шифрование аудио файла перед загрузкой
   - Дешифрование после загрузки

2. **Видеозвонки:**
   - WebRTC уже использует шифрование (DTLS/SRTP)
   - Дополнительное E2EE не требуется

3. **Метаданные:**
   - Время отправки, ID отправителя не шифруются (метаданные)
   - Только содержимое сообщения шифруется

---

## РЕАЛИЗАЦИЯ

### Этап 1: Backend
1. Создать таблицу user_keys
2. Endpoint для сохранения публичного ключа
3. Endpoint для получения публичного ключа пользователя
4. Обновить схему messages для зашифрованных данных

### Этап 2: Frontend Web
1. Генерация RSA ключей
2. Шифрование/дешифрование сообщений
3. Хранение ключей в localStorage
4. Обновление UI для показа статуса шифрования

### Этап 3: Mobile
1. Адаптация шифрования для React Native
2. Хранение ключей в AsyncStorage
3. Обновление UI

### Этап 4: Интеграция
1. Обновить WebSocket для передачи зашифрованных данных
2. Тестирование шифрования/дешифрования
3. Проверка безопасности
